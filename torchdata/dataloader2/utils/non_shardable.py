# Copyright (c) Meta Platforms, Inc. and affiliates.
# All rights reserved.
#
# This source code is licensed under the BSD-style license found in the
# LICENSE file in the root directory of this source tree.


from multiprocessing.queues import Queue
from typing import Dict, List

from torchdata.dataloader2.graph import DataPipe, DataPipeGraph

from torchdata.datapipes.iter import IterDataPipe


class _DummyIterDataPipe(IterDataPipe):
    r"""
    This DataPipe is a placeholder to be replaced by the ``QueueWrapper``
    that connects the worker process for non-shardable DataPipe.
    """
    req_queue: Queue
    res_queue: Queue


def find_shardable_branches(graph: DataPipeGraph) -> List[DataPipe]:
    r"""
    Given the graph of DataPipe generated by ``traverse_dps`` function, return the DataPipe
    instances that don't have ``_DummyIterDataPipe`` (non-shardable DataPipe) in the prior graph.
    """
    assert len(graph) == 1, "DataPipeGraph should only contain a single output DataPipe"

    dps: List[DataPipe] = []
    cache: Dict[int, bool] = {}

    root_dp_id = list(graph.keys())[0]
    root_dp, root_graph = graph[roo_dp_id]

    def helper(root_dp_id, root_dp, root_graph) -> bool:  # pyre-ignore
        if root_dp_id in cache:
            return cache[root_dp_id]
        if type(root_dp) == _DummyIterDataPipe:
            cache[root_dp_id] = False
            return False
        cache[root_dp_id] = True
        for dp_id, (dp, src_graph) in root_graph.items():
            if not helper(dp_id, dp, src_graph):
                cache[root_dp_id] = False
                break
        if not cache[root_dp_id]:
            # All children should have been cached already
            for dp_id in root_graph.keys():
                if cache[dp_id]:
                    dps.append(dp_id)
        return cache[root_dp_id]

    if helper(root_dp_id, root_dp, root_graph):
        dps.append(root_dp)

    return dps
